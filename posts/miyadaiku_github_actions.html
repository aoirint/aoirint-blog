
<!DOCTYPE html>
<html lang="ja-JP">
<head>
  

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>静的サイトジェネレータMiyadaiku + GitHub Actions + GitHub Pagesでブログを作る - えやみぐさ</title>
  


<link rel="shortcut icon" href="../favicon.ico">




<meta property="og:url" content="https://blog.aoirint.com/posts/miyadaiku_github_actions.html" />
<meta property="og:locale" content="ja-JP" />
<meta property="og:type" content="article" />

<meta property="og:title" content="静的サイトジェネレータMiyadaiku + GitHub Actions + GitHub Pagesでブログを作る - えやみぐさ" />

<meta name="description" content="背景 以前静的サイトジェネレータのJekyllを触って記事を書きましたが、 結局（Docker化するだけで満足して）実運用には至らず、 そうこうしているうちに ブログを書きたい欲があっても内容がない時におちいるブログシステム作りたい/整備したい病を発症したので 新し"/>
<meta property="og:description" content="背景 以前静的サイトジェネレータのJekyllを触って記事を書きましたが、 結局（Docker化するだけで満足して）実運用には至らず、 そうこうしているうちに ブログを書きたい欲があっても内容がない時におちいるブログシステム作りたい/整備したい病を発症したので 新し" />

<meta property="article:published_time" content="2020-09-09T09:48:39+09:00" />

<link href="https://blog.aoirint.com/atom.xml" type="application/atom+xml" rel="alternate" title="えやみぐさ Atom Feed" />
<link href="https://blog.aoirint.com/rss.rdf" type="application/rss+xml" rel="alternate" title="えやみぐさ RSS Feed" />

<link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
<link rel="stylesheet" href="../static/aoirint-blog/css/style.css">

<script defer src="../static/fontawesome/js/all.min.js"></script>
  <script defer src="../static/fontawesome/js/v4-shims.min.js"></script>
<link rel="stylesheet" href="../static/pygments/monokai.css">


    
  

  
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-157155944-5"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-157155944-5');
  </script>
  

<script src="../static/aoirint-blog/js/main.js"></script>

<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>


</head>

<body>
  

<nav class="smartphonebar">
  <button class="toggle-sitebar" type="button" onclick="toggleSiteBarIfSmartphone();">
    <i class="fas fa-bars"></i>
  </button>

  <a href="../index.html" class="sitebar-title">
    えやみぐさ
  </a>

  <button class="toggle-tocbar" type="button" onclick="toggleTocBarIfSmartphone();">
    <i class="fas fa-list"></i>
  </button>

</nav>

<aside class="sitebar-box">
  <nav class="sitebar fixed-scrollable">
    <a href="../index.html" class="sitebar-title">
      えやみぐさ
    </a>

    <div class="sitebar-content">
      <ul>
        <li>
          <a href="../index.html" class="navbar-menu-link">
            Index
          </a>
      </ul>

      <ul>
        <li>
          <a href="../rss.rdf" class="navbar-menu-link">
            RSS Feed
          </a>
        <li>
          <a href="../atom.xml" class="navbar-menu-link">
            Atom Feed
          </a>
      </ul>

      <ul>

        <li>
          <a href="https://twitter.com/aoirint" target="_blank" class="navbar-menu-link">
            Twitter
          </a>


        <li>
          <a href="https://github.com/aoirint" target="_blank" class="navbar-menu-link">
            GitHub
          </a>

      </ul>
    </div>

    <div class="sitebar-footer">
      <p class="copyright-text">
        Copyright © 2020 aoirint.
      <p class="poweredby-text">
        Powered by
        <a href="https://github.com/miyadaiku/miyadaiku">Miyadaiku</a>.
    </div>
  </nav>
</aside>

<main class="main-content">

<div class="container">

<article class="article">

<h1 class="article-title"><a href="miyadaiku_github_actions.html">静的サイトジェネレータMiyadaiku + GitHub Actions + GitHub Pagesでブログを作る</a></h1>



<div class="article-metadata">
  <div class="article-date">
    2020-09-09
  </div>

  <div class="article-tags">

    <a href="../index_category_category_技術.html" class="article-category">
      技術
    </a>



    <a href="../index_tag_tags_Miyadaiku.html" class="article-tag">
      Miyadaiku
    </a>

    <a href="../index_tag_tags_Static Website.html" class="article-tag">
      Static Website
    </a>

    <a href="../index_tag_tags_GitHub.html" class="article-tag">
      GitHub
    </a>

    <a href="../index_tag_tags_GitHub Actions.html" class="article-tag">
      GitHub Actions
    </a>

    <a href="../index_tag_tags_CI/CD.html" class="article-tag">
      CI/CD
    </a>

  </div>

</div>



<div class="article-body">
  <h2 class="md_header_block" id="h_posts_miyadaiku_github_actions_md_背景_1">背景</h2>
<p>以前静的サイトジェネレータのJekyllを触って記事を書きましたが、
結局（Docker化するだけで満足して）実運用には至らず、
そうこうしているうちに
ブログを書きたい欲があっても内容がない時におちいるブログシステム作りたい/整備したい病を発症したので
新しい静的サイトジェネレータで環境を整備しようということに相成りました。
細かい使い方には触れませんが、構成を書いておきます。</p>
<h2 class="md_header_block" id="h_posts_miyadaiku_github_actions_md_静的サイトジェネレータとCI_CD_2">静的サイトジェネレータとCI/CD</h2>
<h3 class="md_header_block" id="h_posts_miyadaiku_github_actions_md_静的サイトジェネレータ_3">静的サイトジェネレータ</h3>
<p>静的サイトジェネレータというのはSphinx（Python製）とかJekyll（Ruby製、GitHub Pages標準らしい）とかHugo（Go製）みたいなやつで、
MarkdownだとかreStructuredTextだとかのファイル群からHTMLを生成するツールです。</p>
<ul>
<li><a href="https://www.sphinx-doc.org/">Sphinx</a></li>
<li><a href="https://jekyllrb.com/">Jekyll</a></li>
<li><a href="https://gohugo.io/">Hugo</a></li>
</ul>
<h3 class="md_header_block" id="h_posts_miyadaiku_github_actions_md_Miyadaiku_4">Miyadaiku</h3>
<p><a href="https://miyadaiku.github.io/">Miyadaiku</a>はPython製の静的サイトジェネレータです。
Flaskで使うテンプレートエンジンのJinja2が使えることが特徴みたいです。Jinja2はDjangoのテンプレートエンジンに似ています。
テンプレート上でどんな変数が使えるかはMiyadaikuの領域なので、ドキュメント（とサンプルテンプレート、ソースコード）を見ていくしかないです。</p>
<ul>
<li><a href="https://github.com/miyadaiku/miyadaiku">github:miyadaiku/miyadaiku</a></li>
<li><a href="https://pypi.org/project/miyadaiku/">pypi:miyadaiku</a></li>
</ul>
<h3 class="md_header_block" id="h_posts_miyadaiku_github_actions_md_GitHub_Actions_5">GitHub Actions</h3>
<p>GitHub上のリポジトリに対してpushやPull Requestがなされた時に事前に指定した処理を実行することのできるGitHubの機能です。
Jenkinsなどに近そうです。また、GitLabにも同様の機能があったはずです。
GitHubのサーバで動く仮想環境上でDockerのような使い方でテストケースの実行やリリースファイルのビルド、サーバへのデプロイ、
つまりCI（Continuos Integration、テストやビルドの自動化）/CD（Continuous Delivery、デプロイの自動化）を設定できます。
Pull Requestなどへの自動ラベル付けやSlackへの通知も設定することがあるかと思います。
この設定はYAMLファイルとしてGitリポジトリ内に保存しますが、秘密鍵/トークンなどの情報を参照するための機能もあるみたいです。
バージョン管理システム的な点ではGitは分散型なので文書自体の分散バージョン管理はできますが、
GitHubが落ちたら解消するまで（手元にリポジトリがあっても）GitHub ActionsによるCI/CDができないのが難点な気がします。</p>
<ul>
<li><a href="https://www.githubstatus.com/">GitHub Status</a></li>
</ul>
<h2 class="md_header_block" id="h_posts_miyadaiku_github_actions_md_考えていること_6">考えていること</h2>
<h3 class="md_header_block" id="h_posts_miyadaiku_github_actions_md_レンダリング後のHTMLファイルの分離_7">レンダリング後のHTMLファイルの分離</h3>
<p>Markdownを書いている時に見えるところに（レンダリング後の）HTMLファイルを置きたくないです。
できれば何も考えずに（Markdownで書いた）メモファイルを置くのに使っていた適当なディレクトリの上でコマンドを実行したら
HTTPサーバを介して（オプションで指定したテーマなどで）いい感じにレンダリングしてくれるようなものがいい
（HTMLファイル自体にファイルシステムからアクセスできる必要はない）と思っていました。</p>
<p>このHTMLはMarkdownファイル群とレンダリングのオプションだけでいつでも生成可能だからです。
レンダリング後のファイル自体が見えなければ、後からこのファイルを何かの間違いで編集してしまって正規性（再レンダリングしても差分がない状態）が崩れてしまうことがないです。
それからMarkdownファイルをGitで管理する場合、レンダリング後のファイルの差分には実質的に意味がないので、（見える）commitに含めたくない気持ちがあります。</p>
<p>この部分は適切に.gitignoreやCI/CDを設定すれば大抵の静的サイトジェネレータで実現可能だろうと思います。
今回はGitHub Actionsを使って、GitHub上の仮想環境にリポジトリから文書を読み込んでHTMLを自動生成し、文書と履歴を共有しない別ブランチ（gh-pages）に自動でcommitされるように設定します。</p>
<p>GitHub Actionsを動かすには<code>.github/workflows</code>以下にYAMLファイルを配置します。例えばこのような感じです。GitHub Pagesへのデプロイ（gh-pagesブランチの更新）には<a href="https://github.com/peaceiris/actions-gh-pages">github:peaceiris/actions-gh-pages</a>を使っています。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># deploy.yml</span>
<span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Deploy</span>

<span class="c1"># Controls when the action will run. Triggers the workflow on push or pull request</span>
<span class="c1"># events but only for the master branch</span>
<span class="nt">on</span><span class="p">:</span>
  <span class="nt">push</span><span class="p">:</span>
    <span class="nt">branches</span><span class="p">:</span> <span class="p p-Indicator">[</span> <span class="nv">master</span> <span class="p p-Indicator">]</span>

<span class="c1"># A workflow run is made up of one or more jobs that can run sequentially or in parallel</span>
<span class="nt">jobs</span><span class="p">:</span>
  <span class="c1"># This workflow contains a single job called "build"</span>
  <span class="nt">build</span><span class="p">:</span>
    <span class="c1"># The type of runner that the job will run on</span>
    <span class="nt">runs-on</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">ubuntu-latest</span>

    <span class="c1"># Steps represent a sequence of tasks that will be executed as part of the job</span>
    <span class="nt">steps</span><span class="p">:</span>
      <span class="c1"># Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it</span>
      <span class="p p-Indicator">-</span> <span class="nt">uses</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">actions/checkout@v2</span>

      <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Setup Python</span>
        <span class="nt">uses</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">actions/setup-python@v2</span>
        <span class="nt">with</span><span class="p">:</span>
          <span class="c1"># Version range or exact version of a Python version to use, using SemVer's version range syntax.</span>
          <span class="nt">python-version</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">3.x</span>

      <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Install dependencies</span>
        <span class="nt">run</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">pip3 install -r requirements.txt</span>

      <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Run miyadaiku-build</span>
        <span class="nt">run</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">miyadaiku-build --output public .</span>

      <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Deploy</span>
        <span class="nt">uses</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">peaceiris/actions-gh-pages@v3</span>
        <span class="nt">with</span><span class="p">:</span>
          <span class="nt">github_token</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">${{ secrets.GITHUB_TOKEN }}</span>
          <span class="nt">publish_dir</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">./public</span>
</code></pre></div>
<p><code>name</code>、<code>run</code>のところをコピーして増やせばコマンドを増やすことができます。</p>
<h3 class="md_header_block" id="h_posts_miyadaiku_github_actions_md_テーマと文書の分離_8">テーマと文書の分離</h3>
<p>テーマのリポジトリと文書のリポジトリを分離したいです。
これをすることで、
文書のリポジトリでは本来の目的であるメモやブログの文章に関するcommitだけ（レンダリングの設定ファイルは残ってしまうかもですが）、
テーマのリポジトリでは本来の目的であるHTMLテンプレートに関するcommitだけが
履歴として見えるようになります。
また、テーマのリポジトリだけを公開する、というようなことができるようになります（公開しなくてもgit経由でpip installしたりすればいいです）。</p>
<p>今回はテーマとして<a href="https://github.com/aoirint/aoirint-miyadaiku-theme-blog">aoirint-miyadaiku-theme-blog</a>を作成しました。ついでにPyPIにも登録しました。</p>
<ul>
<li><a href="https://pypi.org/project/aoirint-miyadaiku-theme-blog/">pypi:aoirint-miyadaiku-theme-blog</a></li>
</ul>
<h3 class="md_header_block" id="h_posts_miyadaiku_github_actions_md_文書の書きやすさ_9">文書の書きやすさ</h3>
<p>日付の表示やタグ検索などレンダリング時の質を上げたければ、どうしても文書側にメタデータを付加しなければならないところがネックではある気はしますが、
GitHub上でJekyll的なYAMLヘッダ（Miyadaikuも同様）のついたMarkdownを表示してみたところ、メタデータを整形表示してくれました。
この様子ならある程度互換性が期待できますし、そういう習慣をつけるのもいいのではないかなと思います。</p>
<ul>
<li><a href="https://github.blog/2013-09-27-viewing-yaml-metadata-in-your-documents/">Viewing YAML Metadata in your Documents - The GitHub Blog</a></li>
</ul>
<p>PC上で文書を書いているときには、ブラウザの更新がかかったり、ネットワークが不安定で再起動が必要になったり、OSの更新で勝手に再起動したり、寝落ちしてバッテリが切れたりなど、Webページが強制リロードしたり、エディタが強制終了したりすることがよくあります。こういうときに書きかけの文書をできる限り保全してくれる仕組みがほしいところです。GitHub上で書いているとそこが若干不安なところです。この点ではHackMDを使うのがよさそうに思います（コピーしたファイルを編集する形で、書きかけでもサービス上に自動保存してくれるみたいです）が、CommitterがHackMDになってしまうのが気になるところですね（同時編集するときはこれでよさそうですが）。</p>
<ul>
<li><a href="https://docs.github.com/en/github/using-git/changing-author-info">Changing author info - GitHub Docs</a></li>
</ul>
<p>またUbuntu、Mac、WindowsのPCを時と場所と気分と目的によって切り替えて使っていて、タイミングによっては特定のPCにアクセスできないようなこともあるので、基本的に文書がリモートにないと面倒なのですが、（あんまり分散管理という感じがしませんが）GitHubを経由して同期すればいいというのがGitを使う利点の一つであるように思います。</p>
<p>それから、複数の書きかけの文書/記事があるとき、何度も変更して大量に履歴ができたり、複数の記事の履歴が入り乱れるとつらそうです。これは記事ごとにブランチを切る（あとでmergeする）とか、squash/rebaseを使うとか、Pull Requestを使うとかしてうまく対処できないか考えています。</p>
<h4 class="md_header_block" id="h_posts_miyadaiku_github_actions_md_複数のコミットを1つにまとめる例_10">複数のコミットを1つにまとめる例</h4>
<p>このような4つのコミット履歴のあるブランチがあるとします。</p>
<div class="highlight"><pre><span></span><code>branch A: W--X--Y--Z
</code></pre></div>
<p>まず<code>git log --oneline</code>で対象のcommit IDを調べます。</p>
<div class="highlight"><pre><span></span><code>ZZZZZZ COMMIT Z
YYYYYY COMMIT Y
XXXXXX COMMIT X
WWWWWW COMMIT W
</code></pre></div>
<p><code>git rebase -i COMMIT_ID</code>は指定したIDのcommitの次のcommitから最新のcommitまでの履歴を操作するコマンドです。エディタが開き、上から古い順にコミットが表示されます。<code>git rebase -i WWWWWW</code>を実行すると、このようになります。</p>
<div class="highlight"><pre><span></span><code>pick XXXXXX COMMIT X
pick YYYYYY COMMIT Y
pick ZZZZZZ COMMIT Z
</code></pre></div>
<p>頭の<code>pick</code>を<code>squash</code>か<code>s</code>に変えることで1つ上（前）のcommitに差分が統合されます。保存してエディタを閉じるとコミットメッセージの編集が始まります。なお、失敗してエラーが出たときは<code>git rebase --abort</code>でrebaseを中断できます。</p>
<div class="highlight"><pre><span></span><code>pick XXXXXX COMMIT X
pick YYYYYY COMMIT Y
s    ZZZZZZ COMMIT Z
</code></pre></div>
<div class="highlight"><pre><span></span><code>branch A: W--X--Y'
</code></pre></div>
<p>すでにCOMMIT Y、COMMIT Zがリモートの同ブランチにpushされているときは<code>git push -f</code>する必要があります。</p>
<ul>
<li><a href="https://qiita.com/tsuuuuu_san/items/f708a9f7ea8ab8eb6945">【git rebase -i】gitのcommitをまとめる - Qiita</a></li>
</ul>
<h4 class="md_header_block" id="h_posts_miyadaiku_github_actions_md_複数の記事を同時に書く際の例_11">複数の記事を同時に書く際の例</h4>
<p>まず、masterブランチ、記事Aを書いているブランチA、記事Bを書いているブランチBがあるとします。ブランチAとブランチBはmasterブランチの最終commit Xから分岐しています。</p>
<div class="highlight"><pre><span></span><code>master  : X
           \
branch A:   |--Y
branch B:   |--Z
</code></pre></div>
<p>ここで記事Aを書き終わったので、GitHub上でPull Requestを作成し、masterブランチにmergeしました。ここでmasterブランチの最終commitはcommit Yになります。ブランチBは記事Bのcommit Zをすでに作成していて、masterブランチに対し、1 commit behind、1 commit aheadの状態になりました。</p>
<div class="highlight"><pre><span></span><code>master  : X--------Y
           \
branch B:   |--Z
</code></pre></div>
<p>ここでローカルでの作業に移ります。まずmasterブランチをcheckoutし、<code>git pull</code>してcommit履歴を最新にします。次にブランチBをcheckoutし、<code>git pull</code>してcommit履歴を最新にしたあと、<code>git rebase master</code>を実行することでcommit Yの次にcommit Zがくる1 commit aheadの状態にすることができます。ローカルでブランチBをいじっていた場合は、一度commitしてから同様にrebaseすれば同じことができます（<code>git rebase origin/master</code>というのもできます）。</p>
<div class="highlight"><pre><span></span><code>master  : X--------Y
                    \
branch B:            |--Z
</code></pre></div>
<p>すでに古いcommit履歴のbranch Bがリモートにpushされているときは<code>git push -f</code>する必要があります。</p>
<ul>
<li><a href="https://qiita.com/vsanna/items/451b42f886c599a16a55">fast-forwardマージから理解するgit rebase - Qiita</a></li>
</ul>
<h2 class="md_header_block" id="h_posts_miyadaiku_github_actions_md_Miyadaikuを使う_12">Miyadaikuを使う</h2>
<div class="highlight"><pre><span></span><code>pip3 install miyadaiku
</code></pre></div>
<p><code>miyadaiku==1.17.0</code>とします。
Miyadaikuをpipで入れると<code>miyadaiku-start</code>、<code>miyadaiku-build</code>コマンドが使えるようになります。</p>
<p><code>miyadaiku-start</code>は空のMiyadaikuプロジェクトを作成するコマンドです。といっても空の<code>files</code>、<code>templates</code>ディレクトリ、サンプルのMarkdownファイル<code>index.md</code>の入った<code>contents</code>ディレクトリ、デフォルトのシンプルなコンフィグファイル<code>config.yml</code>が生成されるだけです。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Miyadaiku config file</span>

<span class="c1"># Base URL of the site</span>
<span class="nt">site_url</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">http://localhost:8888/</span>

<span class="c1"># Title of the site</span>
<span class="nt">site_title</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">FIXME - site title</span>

<span class="c1"># Default language code</span>
<span class="nt">lang</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">en-US</span>

<span class="c1"># Default charset</span>
<span class="nt">charset</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">utf-8</span>

<span class="c1"># Default timezone</span>
<span class="nt">timezone</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Asia/Tokyo</span>

<span class="c1"># List of site theme</span>
<span class="c1"># themes:</span>
<span class="c1">#   - miyadaiku.themes.sample.blog</span>
</code></pre></div>
<p><code>files</code>ディレクトリは、汎用的な画像やCSS、JSを置くのに使います。このディレクトリの内容はそのまま出力ディレクトリにコピーされます。
<code>templates</code>ディレクトリには、Jinja2テンプレートを配置します。<code>contents</code>ディレクトリは、中に置いたMarkdownファイルなどがHTMLに変換されたものが出力ディレクトリに吐き出されます。</p>
<p><code>config.yml</code>の<code>themes</code>にpipで入れたテーマのモジュール名を書くことで、そのモジュール内の<code>contents</code>、<code>files</code>、<code>templates</code>が使えるようになります。<code>templates</code>内のHTMLテンプレート（<code>page_index.html</code>など）だけでなく、<code>contents</code>内の記事一覧を表示する<code>index.yml</code>などがテーマで用意されていれば、自分で作る必要はないみたいです。</p>
<p><code>miyadaiku-build</code>はHTMLファイルを生成するコマンドです。デフォルトで<code>outputs</code>ディレクトリに吐き出されます。
<code>--server</code>オプションで簡易サーバが立ち、<code>--watch</code>オプションで更新を自動検出します。<code>miyadaiku-build -sw .</code>で現在のディレクトリにある<code>config.yml</code>をもとに自動更新＆簡易サーバが立ち上がります。</p>
<p><code>.gitignore</code>を次のようにして、記事用のリポジトリを作りました。<code>_depends.pickle</code>というファイルはビルド時に生成されるのですが、バイナリなのでとりあえず載せないようにしています。</p>
<div class="highlight"><pre><span></span><code>/_depends.pickle
/outputs
</code></pre></div>
<p><code>config.yml</code>は<code>pip3 install aoirint_miyadaiku_theme_blog</code>したうえで、次のようにしています。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Miyadaiku config file</span>

<span class="c1"># Base URL of the site</span>
<span class="nt">site_url</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">https://www.example.com</span>

<span class="c1"># Title of the site</span>
<span class="nt">site_title</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">SITE TITLE</span>

<span class="c1"># Default language code</span>
<span class="nt">lang</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">ja</span>

<span class="c1"># Default charset</span>
<span class="nt">charset</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">utf-8</span>

<span class="c1"># Default timezone</span>
<span class="nt">timezone</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Asia/Tokyo</span>

<span class="nt">copyright</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Copyright © 20xx HOLDER.</span>

<span class="nt">favicon</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">/favicon.ico</span>

<span class="c1"># ga_tracking_id: UA-*</span>

<span class="nt">twitter_name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">example</span>
<span class="nt">github_name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">github</span>


<span class="c1"># List of site theme</span>
<span class="nt">themes</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">aoirint_miyadaiku_theme_blog</span>
</code></pre></div>
<p>ディレクトリ構成はこのような感じです。</p>
<div class="highlight"><pre><span></span><code>blog-repository/
|- .git/            # git管理
|- .github/         # GitHub Action用
|- contents/        # 記事を書くディレクトリ
   |- post1.md
|- files/           # 共通ファイルを置くディレクトリ
   |- favicon.ico
|- .gitignore
|- config.yml
|- requirements.txt # miyadaiku、テーマのインストール用
</code></pre></div>
<p>これで<code>miyadaiku-build -sw .</code>を実行すればデフォルトのポートに簡易サーバが立ち、実際のレンダリングをみることができます。</p>
</div>


</article>

</div>

</main>

<aside class="tocbar-box">
  <nav class="tocbar fixed-scrollable">

<script>
  generateTocBar(
    document.querySelector('.article-body'),
    document.querySelector('.tocbar'),
    document.querySelector('.article-title'),
  );
</script>

  </nav>
</aside>


</body>
</html>